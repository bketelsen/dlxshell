#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dlx_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx - LXD Helper Scripts\n"
    echo 
  else
    printf "dlx - LXD Helper Scripts\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dlx [command]\n"
  printf "  dlx [command] --help | -h\n"
  printf "  dlx --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  doctor        Check system readiness"
  echo "  list          List containers"
  echo "  build         Build base image"
  echo "  run           Create and run a container"
  echo "  shell         Start an interactive shell in a container"
  echo "  stop          Stop a running container"
  echo "  delete        Delete a container"
  echo "  completions   Generate bash completion scripts. Add `eval "$(dlx completions)"` to your ~/.bashrc to use them."
  echo "  scripts       Open the example scripts directory"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dlx_doctor_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx doctor - Check system readiness\n"
    echo 
  else
    printf "dlx doctor - Check system readiness\n"
    echo 
  fi

  printf "Shortcut: d\n"
  echo

  printf "Usage:\n"
  printf "  dlx doctor\n"
  printf "  dlx doctor --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dlx doctor\n"
    echo

  fi
}

# :command.usage
dlx_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx list - List containers\n"
    echo 
  else
    printf "dlx list - List containers\n"
    echo 
  fi

  printf "Shortcut: l\n"
  echo

  printf "Usage:\n"
  printf "  dlx list\n"
  printf "  dlx list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  dlx list\n"
    echo

  fi
}

# :command.usage
dlx_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx build - Build base image\n"
    echo 
  else
    printf "dlx build - Build base image\n"
    echo 
  fi

  printf "Shortcut: b\n"
  echo

  printf "Usage:\n"
  printf "  dlx build\n"
  printf "  dlx build --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dlx_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx run - Create and run a container\n"
    echo 
  else
    printf "dlx run - Create and run a container\n"
    echo 
  fi

  printf "Shortcut: r\n"
  echo

  printf "Usage:\n"
  printf "  dlx run NAME\n"
  printf "  dlx run --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  NAME"
    printf "    Container name\n"
    echo

  fi
}

# :command.usage
dlx_shell_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx shell - Start an interactive shell in a container\n"
    echo 
  else
    printf "dlx shell - Start an interactive shell in a container\n"
    echo 
  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  dlx shell CONTAINER\n"
  printf "  dlx shell --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  CONTAINER"
    printf "    Container name\n"
    echo

  fi
}

# :command.usage
dlx_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx stop - Stop a running container\n"
    echo 
  else
    printf "dlx stop - Stop a running container\n"
    echo 
  fi

  printf "Shortcut: p\n"
  echo

  printf "Usage:\n"
  printf "  dlx stop NAME\n"
  printf "  dlx stop --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  NAME"
    printf "    Container name\n"
    echo

  fi
}

# :command.usage
dlx_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx delete - Delete a container\n"
    echo 
  else
    printf "dlx delete - Delete a container\n"
    echo 
  fi

  printf "Shortcut: k\n"
  echo

  printf "Usage:\n"
  printf "  dlx delete NAME\n"
  printf "  dlx delete --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  NAME"
    printf "    Container name\n"
    echo

  fi
}

# :command.usage
dlx_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx completions - Generate bash completion scripts. Add `eval "$(dlx completions)"` to your ~/.bashrc to use them.\n"
    echo 
  else
    printf "dlx completions - Generate bash completion scripts. Add `eval "$(dlx completions)"` to your ~/.bashrc to use them.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dlx completions\n"
  printf "  dlx completions --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dlx_scripts_usage() {
  if [[ -n $long_usage ]]; then
    printf "dlx scripts - Open the example scripts directory\n"
    echo 
  else
    printf "dlx scripts - Open the example scripts directory\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  dlx scripts\n"
  printf "  dlx scripts --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/config.sh
# ---
# Config functions
# This file is a part of Bashly standard library
#
# Usage:
# - In your script, set the CONFIG_FILE variable. For rxample:
#   CONFIG_FILE=settings.ini.
#   If it is unset, it will default to 'config.ini'.
# - Use any of the functions below to access the config file.
# ---

# Create a new config file.
# There is normally no need to use this function, it is used by other
# functions as needed.
config_init() {
  CONFIG_FILE=${CONFIG_FILE:=config.ini}
  [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
}

# Get a value from the config.
# Usage: result=$(config_get hello)
config_get() {
  key=$1
  regex="^$key *= *(.+)$"

  config_init
  
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[1]}"
      break
    fi
  done < "$CONFIG_FILE"

  echo "$value"
}

# Add or update a key=value pair in the config.
# Usage: config_set key value
config_set() {
  key=$1
  shift
  value="$*"

  config_init

  regex="^($key) *= *.+$"
  output=""
  found_key=""
  
  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[1]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Delete a key from the config.
# Usage: config_del key
config_del() {
  key=$1

  regex="^($key) *="
  output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Show the config file
config_show() {
  config_init
  cat "$CONFIG_FILE"
}

# Return an array of the keys in the config file.
# Usage:
#
#   for k in $(config_keys); do
#     echo "- $k = $(config_get "$k")";
#   done
#
config_keys() {
  regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      keys+=("$key")
    fi
  done < "$CONFIG_FILE"
  echo "${keys[@]}"
}

# Returns true if the specified key exists in the config file.
# Usage:
#
#   if config_has_key "key" ; then
#     echo "key exists"
#   fi
#
config_has_key() {
  [[ $(config_get "$1") ]]
}

# :src/lib/create_base.sh
# Add any function here that is needed in more than one parts of your
# application, or that you otherwise wish to extract from the main function
# scripts.
#
# Note that code here should be wrapped inside bash functions, and it is
# recommended to have a separate file for each function.
#
# Subdirectories will also be scanned for *.sh, so you have no reason not
# to organize your code neatly.
#
create_base() {
cat << EOF > $RECIPE_CONFIG_HOME/base.yaml
image:
  description: Ubuntu {{ image.release }}
  distribution: ubuntu
  release: focal
  architecture: x86_64
  name: ubuntu-disco-x86_64
  architecture_mapped: amd64
  architecture_kernel: x86_64
  architecture_personality: linux64
source:
  downloader: debootstrap
  url: http://archive.ubuntu.com/ubuntu
  keys:
  - 0x790BC7277767219C42C86F933B4FE6ACC0B21F32
  - 0xf6ecb3762474eda9d21b7022871920d1991bc93c
  keyserver: keyserver.ubuntu.com
  same_as: gutsy
targets:
  lxc:
    create-message: |-
      You just created an {{ image.description }} container.

      To enable SSH, run: apt install openssh-server
      No default root or user password are set by LXC.
    config:
    - type: all
      before: 5
      content: lxc.include = LXC_TEMPLATE_CONFIG/ubuntu.common.conf
    - type: user
      before: 5
      content: lxc.include = LXC_TEMPLATE_CONFIG/ubuntu.userns.conf
    - type: all
      after: 4
      content: |-
        lxc.include = LXC_TEMPLATE_CONFIG/common.conf

        # For Ubuntu 14.04
        lxc.mount.entry = /sys/kernel/debug sys/kernel/debug none bind,optional 0 0
        lxc.mount.entry = /sys/kernel/security sys/kernel/security none bind,optional 0 0
        lxc.mount.entry = /sys/fs/pstore sys/fs/pstore none bind,optional 0 0
        lxc.mount.entry = mqueue dev/mqueue mqueue rw,relatime,create=dir,optional 0 0
    - type: user
      after: 4
      content: |-
        lxc.include = LXC_TEMPLATE_CONFIG/userns.conf

        # For Ubuntu 14.04
        lxc.mount.entry = /sys/firmware/efi/efivars sys/firmware/efi/efivars none bind,optional 0 0
        lxc.mount.entry = /proc/sys/fs/binfmt_misc proc/sys/fs/binfmt_misc none bind,optional 0 0
    - type: all
      content: lxc.arch = {{ image.architecture_personality }}
  type: ""
files:
- generator: hostname
  path: /etc/hostname
- generator: hosts
  path: /etc/hosts
- generator: remove
  path: /etc/resolvconf/resolv.conf.d/original
- generator: remove
  path: /etc/resolvconf/resolv.conf.d/tail
- generator: dump
  path: /etc/machine-id
- generator: remove
  path: /var/lib/dbus/machine-id
- releases:
  - bionic
  - eoan
  - focal
  - groovy
  variants:
  - default
  types:
  - container
  generator: dump
  path: /etc/netplan/10-lxc.yaml
  content: |-
    network:
      version: 2
      ethernets:
        eth0:
          dhcp4: true
          dhcp-identifier: mac
- releases:
  - trusty
  - xenial
  types:
  - container
  generator: dump
  path: /etc/network/interfaces
  content: |-
    # This file describes the network interfaces available on your system
    # and how to activate them. For more information, see interfaces(5).

    # The loopback network interface
    auto lo
    iface lo inet loopback

    auto eth0
    iface eth0 inet dhcp

    source /etc/network/interfaces.d/*.cfg
- releases:
  - bionic
  - eoan
  - focal
  - groovy
  variants:
  - default
  types:
  - vm
  generator: dump
  path: /etc/netplan/10-lxc.yaml
  content: |-
    network:
      version: 2
      ethernets:
        enp5s0:
          dhcp4: true
          dhcp-identifier: mac
- releases:
  - trusty
  - xenial
  types:
  - vm
  generator: dump
  path: /etc/network/interfaces
  content: |-
    # This file describes the network interfaces available on your system
    # and how to activate them. For more information, see interfaces(5).

    # The loopback network interface
    auto lo
    iface lo inet loopback

    auto enp5s0
    iface enp5s0 inet dhcp

    source /etc/network/interfaces.d/*.cfg
- releases:
  - trusty
  types:
  - container
  generator: upstart-tty
  path: /etc/init/lxc-tty.conf
- variants:
  - cloud
  generator: cloud-init
  name: meta-data
- variants:
  - cloud
  generator: cloud-init
  name: network-config
- variants:
  - cloud
  generator: cloud-init
  name: user-data
- variants:
  - cloud
  generator: cloud-init
  name: vendor-data
- types:
  - vm
  generator: fstab
  name: ext4
- types:
  - vm
  generator: lxd-agent
  name: lxd-agent
- types:
  - vm
  generator: dump
  path: /etc/default/grub.d/50-lxd.cfg
  content: |-
    GRUB_RECORDFAIL_TIMEOUT=0
    GRUB_TIMEOUT=0
    GRUB_CMDLINE_LINUX_DEFAULT="${GRUB_CMDLINE_LINUX_DEFAULT} console=tty1 console=ttyS0"
    GRUB_TERMINAL=console
- variants:
  - default
  generator: dump
  path: /etc/sudoers.d/90-lxd
  content: |-
    # User rules for dlx
    dlx ALL=(ALL) NOPASSWD:ALL
  mode: "0440"
packages:
  manager: apt
  update: true
  cleanup: true
  sets:
  - packages:
    - apt-transport-https
    - fuse
    - language-pack-en
    - openssh-client
    - openssh-server
    - vim
    action: install
  - variants:
    - cloud
    packages:
    - cloud-init
    action: install
  - architectures:
    - amd64
    - arm64
    types:
    - vm
    packages:
    - acpid
    action: install
  - architectures:
    - amd64
    types:
    - vm
    packages:
    - grub-efi-amd64-signed
    - shim-signed
    action: install
  - architectures:
    - arm64
    types:
    - vm
    packages:
    - grub-efi-arm64-signed
    action: install
  - releases:
    - disco
    - eoan
    - focal
    - groovy
    architectures:
    - arm64
    types:
    - vm
    packages:
    - shim-signed
    action: install
  - releases:
    - xenial
    types:
    - vm
    packages:
    - linux-virtual-hwe-16.04
    action: install
  - releases:
    - bionic
    - eoan
    - focal
    - groovy
    types:
    - vm
    packages:
    - linux-virtual
    action: install
  - types:
    - vm
    packages:
    - os-prober
    action: remove
  - packages:
    - tailscale
    action: install
  repositories:
  - architectures:
    - amd64
    - i386
    name: sources.list
    url: |-
      deb http://archive.ubuntu.com/ubuntu {{ image.release }} main restricted universe multiverse
      deb http://archive.ubuntu.com/ubuntu {{ image.release }}-updates main restricted universe multiverse
      deb http://security.ubuntu.com/ubuntu {{ image.release }}-security main restricted universe multiverse
  - architectures:
    - armhf
    - arm64
    - powerpc
    - powerpc64
    - ppc64el
    name: sources.list
    url: |-
      deb http://ports.ubuntu.com/ubuntu-ports {{ image.release }} main restricted universe multiverse
      deb http://ports.ubuntu.com/ubuntu-ports {{ image.release }}-updates main restricted universe multiverse
      deb http://ports.ubuntu.com/ubuntu-ports {{ image.release }}-security main restricted universe multiverse
  - name: sources.list
    url: deb https://pkgs.tailscale.com/stable/ubuntu {{ image.release }} main
    key: |
      -----BEGIN PGP PUBLIC KEY BLOCK-----

      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
      =AIVM
      -----END PGP PUBLIC KEY BLOCK-----
actions:
- variants:
  - default
  trigger: post-update
  action: |-
    #!/bin/sh
    set -eux

    # Create the dlx user account
    getent group sudo >/dev/null 2>&1 || groupadd --system sudo
    useradd --create-home -s /bin/bash -G sudo -U dlx
- releases:
  - bionic
  - eoan
  - focal
  - groovy
  trigger: post-packages
  action: |-
    #!/bin/sh
    set -eux

    # Enable systemd-networkd
    systemctl enable systemd-networkd
- trigger: post-packages
  action: |-
    #!/bin/sh
    set -eux

    # Make sure the locale is built and functional
    locale-gen en_US.UTF-8
    update-locale LANG=en_US.UTF-8

    # Cleanup underlying /run
    mount -o bind / /mnt
    rm -rf /mnt/run/*
    umount /mnt

    # Cleanup temporary shadow paths
    rm /etc/*-
- types:
  - vm
  trigger: post-files
  action: |-
    #!/bin/sh
    set -eux

    TARGET="x86_64"
    [ "$(uname -m)" = "aarch64" ] && TARGET="arm64"

    update-grub
    grub-install --uefi-secure-boot --target="${TARGET}-efi" --no-nvram --removable
    update-grub
    sed -i "s#root=[^ ]*#root=/dev/sda2#g" /boot/grub/grub.cfg
mappings:
  architecture_map: debian

EOF
current_user=`whoami`
old="dlx"
filename="data.txt"
sed -i "s/$old/$current_user/" $RECIPE_CONFIG_HOME/base.yaml
}

# :src/lib/create_scripts.sh
# Add any function here that is needed in more than one parts of your
# application, or that you otherwise wish to extract from the main function
# scripts.
#
# Note that code here should be wrapped inside bash functions, and it is
# recommended to have a separate file for each function.
#
# Subdirectories will also be scanned for *.sh, so you have no reason not
# to organize your code neatly.
#
create_scripts() {
cat << EOF > $SCRIPT_CONFIG_HOME/debootstrap.sh
#!/bin/bash

sudo apt-get install -y debootstrap
EOF
chmod +x $SCRIPT_CONFIG_HOME/debootstrap.sh

cat << EOF > $SCRIPT_CONFIG_HOME/distrobuilder.sh
#!/bin/bash

sudo snap install distrobuilder
EOF
chmod +x $SCRIPT_CONFIG_HOME/distrobuilder.sh

cat << EOF > $SCRIPT_CONFIG_HOME/lxd.sh
#!/bin/bash

sudo snap install lxd --classic
EOF
chmod +x $SCRIPT_CONFIG_HOME/lxd.sh

cat << EOF > $SCRIPT_CONFIG_HOME/subuid.sh
#!/bin/bash
echo "root:1000:1" | sudo tee -a /etc/subuid /etc/subgid
EOF
chmod +x $SCRIPT_CONFIG_HOME/subuid.sh

cat << EOF > $SCRIPT_CONFIG_HOME/01_network-manager-all.yaml
network:
  version: 2
  renderer: NetworkManager

  ethernets:
    enxf01dbc977754:
      dhcp4: no

  bridges:
    br0:
      dhcp4: yes
      interfaces:
        - enxf01dbc977754

EOF

cat << EOF > $SCRIPT_CONFIG_HOME/bridge.profile
config: {}
description: ""
devices:
  eth0:
    name: eth0
    nictype: bridged
    parent: br0
    type: nic
name: bridgeprofile
used_by: []
EOF

cat << EOF > $SCRIPT_CONFIG_HOME/default.profile
config:
  raw.idmap: |
    both 1000 1000
description: Default LXD profile
devices:
  eth0:
    name: eth0
    network: lxdbr0
    type: nic
  root:
    path: /
    pool: default
    type: disk
name: default
used_by: []
EOF
}

# :src/lib/installed.sh
# Add any function here that is needed in more than one parts of your
# application, or that you otherwise wish to extract from the main function
# scripts.
#
# Note that code here should be wrapped inside bash functions, and it is
# recommended to have a separate file for each function.
#
# Subdirectories will also be scanned for *.sh, so you have no reason not
# to organize your code neatly.
#
assert_installed() {
    for var in "$@"; do
        if ! [ -x "$(command -v $var)" ]; then
            echo "$var is not installed."
            exit 1
        fi
    done
}

# :src/lib/send_completions.sh
send_completions() {
  echo $'#!/usr/bin/env bash'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $'_dlx_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local comp_line="${COMP_WORDS[*]:1}"'
  echo $''
  echo $'  case "$comp_line" in'
  echo $'    \'doctor\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'delete\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'build\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'shell\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'list\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'stop\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'run\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'\'*) COMPREPLY=($(compgen -W "--help --version -h -v build delete doctor list run shell stop" -- "$cur")) ;;'
  echo $'  esac'
  echo $'}'
  echo $''
  echo $'complete -F _dlx_completions dlx'
}

# :command.command_functions
# :command.function
dlx_doctor_command() {
  # :src/doctor_command.sh
  #inspect_args
  
  
  assert_installed lxd distrobuilder debootstrap
  
  echo Required dependencies are installed.
}

# :command.function
dlx_list_command() {
  # :src/list_command.sh
  lxc ls
}

# :command.function
dlx_build_command() {
  # :src/build_command.sh
  #inspect_args
  
  pushd $RECIPE_CONFIG_HOME
  # build the base image
  sudo distrobuilder build-lxd base.yaml
  # remove the existing base image
  set +e
  lxc image delete dlxbase
  set -e
  # import the new base image
  lxc image import lxd.tar.xz rootfs.squashfs --alias dlxbase
  popd
}

# :command.function
dlx_run_command() {
  # :src/run_command.sh
  container=${args[name]}
  
  mkdir -p $HOME/projects/$container
  profiles="default bridgeprofile"
  profilearray=($profiles)
  profilelist=""
  for (( i=0; i<${#profilearray[@]}; i++ )); do
       profilelist+="--profile ${profilearray[$i]} "
  
  done
  echo $profilelist
  
  lxc launch dlxbase $container $profilelist
  lxc exec $container -- sh -c "mkdir -p /home/`whoami`/projects && chown -R `whoami`:`whoami` /home/`whoami`/projects"
  lxc config device add $container dlxbind disk source=$HOME/projects/$container path=/home/`whoami`/projects/$container
}

# :command.function
dlx_shell_command() {
  # :src/shell_command.sh
  container=${args[container]}
  
  lxc exec $container -- su --login `whoami`
}

# :command.function
dlx_stop_command() {
  # :src/stop_command.sh
  container=${args[name]}
  
  lxc stop $container 
}

# :command.function
dlx_delete_command() {
  # :src/delete_command.sh
  container=${args[name]}
  
  lxc rm $container 
}

# :command.function
dlx_completions_command() {
  # :src/completions_command.sh
  send_completions
}

# :command.function
dlx_scripts_command() {
  # :src/scripts_command.sh
  echo "################################################################"
  echo "#                         WARNING!                             #"
  echo "################################################################"
  echo "# These scripts are provided as examples only."
  echo
  echo "# Using them without understanding what they are doing"
  echo "# may cause loss of data, limbs, or life."
  echo 
  echo "# Consult linuxcontainers.org for documentation on installation"
  echo "# and configuration of lxd."
  echo
  echo "################################################################"
  echo "#                         WARNING!                             #"
  echo "################################################################"
  cd $SCRIPT_CONFIG_HOME
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  doctor | d )
    action="doctor"
    shift
    dlx_doctor_parse_requirements "$@"
    shift $#
    ;;    
  
  list | l )
    action="list"
    shift
    dlx_list_parse_requirements "$@"
    shift $#
    ;;    
  
  build | b )
    action="build"
    shift
    dlx_build_parse_requirements "$@"
    shift $#
    ;;    
  
  run | r )
    action="run"
    shift
    dlx_run_parse_requirements "$@"
    shift $#
    ;;    
  
  shell | s )
    action="shell"
    shift
    dlx_shell_parse_requirements "$@"
    shift $#
    ;;    
  
  stop | p )
    action="stop"
    shift
    dlx_stop_parse_requirements "$@"
    shift $#
    ;;    
  
  delete | k )
    action="delete"
    shift
    dlx_delete_parse_requirements "$@"
    shift $#
    ;;    
  
  completions )
    action="completions"
    shift
    dlx_completions_parse_requirements "$@"
    shift $#
    ;;    
  
  scripts )
    action="scripts"
    shift
    dlx_scripts_parse_requirements "$@"
    shift $#
    ;;    
  
  # :command.command_fallback
  * )
    dlx_usage
    exit 1
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_doctor_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_doctor_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="doctor"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_list_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_list_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="list"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_build_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_build_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v lxd)" ]]; then
    printf "missing dependency: lxd\n"
    exit 1
  fi
  if ! [[ -x "$(command -v debootstrap)" ]]; then
    printf "missing dependency: debootstrap\n"
    exit 1
  fi
  if ! [[ -x "$(command -v distrobuilder)" ]]; then
    printf "missing dependency: distrobuilder\n"
    exit 1
  fi
  # :command.command_filter
  action="build"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_run_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_run_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v lxd)" ]]; then
    printf "missing dependency: lxd\n"
    exit 1
  fi
  # :command.command_filter
  action="run"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[name]=$1
    shift
  else
    printf "missing required argument: NAME\nusage: dlx run NAME\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[name]} ]]; then
        args[name]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_shell_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_shell_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v lxd)" ]]; then
    printf "missing dependency: lxd\n"
    exit 1
  fi
  # :command.command_filter
  action="shell"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[container]=$1
    shift
  else
    printf "missing required argument: CONTAINER\nusage: dlx shell CONTAINER\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[container]} ]]; then
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_stop_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_stop_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v lxd)" ]]; then
    printf "missing dependency: lxd\n"
    exit 1
  fi
  # :command.command_filter
  action="stop"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[name]=$1
    shift
  else
    printf "missing required argument: NAME\nusage: dlx stop NAME\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[name]} ]]; then
        args[name]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_delete_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_delete_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v lxd)" ]]; then
    printf "missing dependency: lxd\n"
    exit 1
  fi
  # :command.command_filter
  action="delete"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[name]=$1
    shift
  else
    printf "missing required argument: NAME\nusage: dlx delete NAME\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[name]} ]]; then
        args[name]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_completions_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_completions_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="completions"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dlx_scripts_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    dlx_scripts_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="scripts"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
    printf "bash version 4 or higher is required\n"
    exit 1
  fi

  # :src/initialize.sh
  XDG_CONFIG_HOME=($HOME/.config)
  dlx_CONFIG_HOME=($XDG_CONFIG_HOME/dlx)
  RECIPE_CONFIG_HOME=($dlx_CONFIG_HOME/recipes)
  PROFILE_CONFIG_HOME=($dlx_CONFIG_HOME/profiles)
  SCRIPT_CONFIG_HOME=($dlx_CONFIG_HOME/scripts)
  
  if [ ! -d "$dlx_CONFIG_HOME" ]; then
  	`mkdir -p $dlx_CONFIG_HOME`;
  	`mkdir -p $RECIPE_CONFIG_HOME`;
  	`mkdir -p $PROFILE_CONFIG_HOME`;
  	`mkdir -p $SCRIPT_CONFIG_HOME`;
  	create_base;
  	create_scripts;
  fi
  CONFIG_FILE=${dlx_CONFIG_HOME}/dlx.ini
}

# :command.run
run() {
  declare -A args
  declare -a other_args
  declare -a input
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "doctor" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_doctor_usage
    else
      dlx_doctor_command
    fi
  
  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_list_usage
    else
      dlx_list_command
    fi
  
  elif [[ $action == "build" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_build_usage
    else
      dlx_build_command
    fi
  
  elif [[ $action == "run" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_run_usage
    else
      dlx_run_command
    fi
  
  elif [[ $action == "shell" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_shell_usage
    else
      dlx_shell_command
    fi
  
  elif [[ $action == "stop" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_stop_usage
    else
      dlx_stop_command
    fi
  
  elif [[ $action == "delete" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_delete_usage
    else
      dlx_delete_command
    fi
  
  elif [[ $action == "completions" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_completions_usage
    else
      dlx_completions_command
    fi
  
  elif [[ $action == "scripts" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dlx_scripts_usage
    else
      dlx_scripts_command
    fi
  
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
